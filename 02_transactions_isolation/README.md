# Работа с уровнями изоляции транзакции в PostgreSQL

1. начать новую транзакцию в обоих сессиях с дефолтным (не меняя) уровнем изоляции<br>
в первой сессии добавить новую запись insert into persons(first_name, second_name) values('sergey', 'sergeev');<br>
сделать select * from persons во второй сессии<br>
**видите ли вы новую запись и если да то почему?**
> Нет, т.к. транзакция во второй сессии не видит изменения транзакции в первой сессии, т.к. они еще не закоммичены - аномалия грязного чтения исключена для уровня Read Committed, а в PostgreSQL в принципе недопустима.

2. завершить первую транзакцию - commit;<br>
сделать select * from persons во второй сессии<br>
**видите ли вы новую запись и если да то почему?**<br>
> Да, т.к. транзакция в первой сессия закоммитила изменения, а Read Committed допускает аномалию Nonrepeatable reads

3. завершите транзакцию во второй сессии<br>
начать новые но уже repeatable read транзации - set transaction isolation level repeatable read;<br>
в первой сессии добавить новую запись insert into persons(first_name, second_name) values('sveta', 'svetova');<br>
сделать select * from persons во второй сессии<br>
**видите ли вы новую запись и если да то почему?**
> Нет, т.к. транзакция во второй сессии не видит изменения транзакции в первой сессии, т.к. они еще не закоммичены - аномалия грязного чтения исключена для уровня Repeatable Read, а в PostgreSQL в принципе недопустима.

4. завершить первую транзакцию - commit;<br>
сделать select * from persons во второй сессии<br>
**видите ли вы новую запись и если да то почему?**
> Нет, т.к. уровень изоляции Repeatable Read не допускает аномалию Nonrepeatable reads

5. завершить вторую транзакцию<br>
сделать select * from persons во второй сессии<br>
**видите ли вы новую запись и если да то почему?** 
> Да, так как в новой транзакции второй сессии доступны изменения из ранее (до старта новой транзакции) закоммиченной транзакции первой сессии.
